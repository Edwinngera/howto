-------------------------------------------------------------------
How do I find all files containing specific text on Linux?
-------------------------------------------------------------------

grep -rnw '/path/to/somewhere/' -e 'pattern'
grep --include=\*.{c,h} -rnw '/path/to/somewhere/' -e "pattern"
grep --exclude=*.o -rnw '/path/to/somewhere/' -e "pattern"
grep --exclude-dir={dir1,dir2,*.dst} -rnw '/path/to/somewhere/' -e "pattern"
grep -Ril "text-to-find-here" /
grep -r "string to be searched"  /path/to/dir

find . -name '*.js' -exec grep -i 'string to search for' {} \; -print
find / -type f | xargs grep 'text-to-find-here'
find / -type f -exec grep -l "text-to-find-here" {} \;
find . -name "*.txt" | xargs grep -i "text_pattern"
find / -type f -exec grep -H 'text-to-find-here' {} \;
find . -type f -name some_file_name.xml -exec grep -H PUT_YOUR_STRING_HERE {} \;
find / -type f -exec grep -sH 'text-to-find-here' {} \; 2>/dev/null

grep -inr "Text" folder/to/be/searched/


grep "text string to search” directory-path
grep [option] "text string to search” directory-path
grep -r "text string to search” directory-path
grep -r -H "text string to search” directory-path
egrep -R "word-1|word-2” directory-path
egrep -w -R "word-1|word-2” directory-path

---------------------------------------------------------
How can I copy files with duplicate filenames into one directory and retain both files by having the duplicate(s) rename automatically?
---------------------------------------------------------

cp --backup=existing --suffix=.orig ~/Music/* ~/Videos
cp -R --backup=existing --suffix=.orig ~/Music ~/Videos
cp --backup=existing --suffix=.orig ~/Music/* ~/Videos

#!/bin/bash
cp -vn "$1" "$2"/ || cp -vn "$1" "$2"/"${1##*/}"~"$(md5sum "$1" | cut -f1 -d' ')"
find . -name 'z*.jpg' -exec ./saveCopy {} /tmp/Extracted/ \;

---------------------------------------------------------------
How do I find all files containing specific text on Linux?
---------------------------------------------------------------

grep -rnw '/path/to/somewhere/' -e 'pattern'
grep --include=\*.{c,h} -rnw '/path/to/somewhere/' -e "pattern"
grep --exclude=*.o -rnw '/path/to/somewhere/' -e "pattern"
grep --exclude-dir={dir1,dir2,*.dst} -rnw '/path/to/somewhere/' -e "pattern"
grep -Ril "text-to-find-here" /
grep -r "string to be searched"  /path/to/dir


find . -name '*.js' -exec grep -i 'string to search for' {} \; -print
find / -type f -exec grep -l "text-to-find-here" {} \;
find . -name "*.txt" | xargs grep -i "text_pattern"
find / -type f -exec grep -H 'text-to-find-here' {} \;
find / -type f -exec grep -H 'text-to-find-here' {} \;


grep "text string to search” directory-path
grep [option] "text string to search” directory-path
grep -r "text string to search” directory-path
grep -r -H "text string to search” directory-path
egrep -R "word-1|word-2” directory-path
egrep -w -R "word-1|word-2” directory-path

-------------------------------------------------------
How to copy files
-------------------------------------------------------

rsync -r source/ destination
cp -r ~/folder1/. ~/new_folder1
cp -avr /home/vivek/letters /usb/backup

scp /path/to/file/* user@server:/path/to/files/
scp /path/to/*/* user@server:/path/to/files/


-------------------------------------------------------
How to move/override files/folder - use cp instead of mv
-------------------------------------------------------

mv - does not support the update/override option, unlike rsync and cp.
Using cp (followed by rm) is the easiest way to perform an update move operation:

$ cp -avu * [destination]
$ rm -rf *


-------------------------------------------------------
How can you move (or copy) all files of a certain type to a directory in Unix?
--------------------------------------------------------

find source -name "*.xxx" -exec mv -i {} -t ~/dst \;
find source -name "*.xxx" -exec mv -i -t ~/dst {} +
find . -name '*.xxx' -exec mv -i {} ~/new-directory \;
find . -name '*.xxx' -exec cp -iv --parents -t /path/to/target_dir {} +
find . -name '*.xxx' -exec sh -c 'mv -i "$@" "$0"' ~/new-directory {} +

-----------------------------------------------------
Finding multiple files recursively and renaming in linux
------------------------------------------------------

find . -iname "*dbg*" -exec rename _dbg.txt .txt '{}' \;

#!/bin/bash
for file in $(find /tmp -name '*.txt') do mv $file $(echo "$file" | sed -r 's|.txt|.cpp|g') done

find -iname \*.* | rename -v "s/ /-/g"
find /tmp -name "*.txt" -exec bash -c 'mv $0 $(echo "$0" | sed -r \"s|.txt|.cpp|g\")' '{}' \;


---------------------------------------------
Linux: create random directory/file hierarchy
---------------------------------------------

mkdir -p {a,b}/{e,f,g}/{h,i,j}


----------------------------------------------
How to count all the lines of code in a directory recursively?
----------------------------------------------

find . -name '*.php' | xargs wc -l
find . -name '*.php' -o -name '*.inc' | xargs wc -l
find . -name "*.php" -not -path "./tests*" | xargs wc -l
( find ./ -name '*.php' -print0 | xargs -0 cat ) | wc -l
find -name '*.php' | xargs cat | wc -l

find . -type f -exec wc -l {} \; | awk '{ SUM += $0} END { print SUM }'
find . -name *.py -exec wc -l {} \; | awk '{ SUM += $0} END { print SUM }'
find . -name '*.php' -type f -exec cat -- {} + | wc -l


find . -name '*.php' -type f | xargs wc -l # Lines in each file
find . -name '*.php' -type f | sort | xargs wc -l # Lines in each file, sorted by file path
find . -name '*.php' -type f | xargs wc -l | sort -nr # Lines in each file, sorted by number of lines, descending
find . -name '*.php' -type f | xargs cat | wc -l # total lines in all files

wc `find | grep .php$`


----------------------------------------
recursively add file extension to all files
----------------------------------------

find . -type f -exec mv '{}' '{}'.jpg \;
find /path -type f -not -name "*.*" -exec mv "{}" "{}".jpg \;
find /path -type f -not -name "*.*" -print0 | xargs -0 rename 's/(.)$/$1.jpg/'
for f in $(find . -type f); do mv $f ${f}.jpg; done



-------------------------------------
Add prefix to all files (recursive)
-------------------------------------

find . -name '*.jpg' -printf "'%p' '%h/thumb_%f'\n" | xargs -n2  echo mv
find . -name \*.jpg -print0 | perl -MFile::Basename -0nle 'rename $_, dirname($_)."/thumb_".basename($_)'
find . -iname \*.JPG -exec bash -c 'mv "$1" "`echo $1 | sed \"s/\(.*\)\//\1\/thumb/\"`"' -- '{}' \;

for file in *.JPG; do mv $file thumb_$file; done
for file in $(find . -name '*.JPG'); do mv $file $(dirname $file)/thumb_$(basename $file); done

# test
mkdir test test/a test/a/b test/a/b/c
touch test/a/A.JPG test/a/b/B.JPG test/a/b/c/C.JPG
cd test
for file in $(find . -name '*.JPG'); do mv $file $(dirname $file)/thumb_$(basename $file); done
find .


rename 's/(\w{1})\.JPG$/thumb_$1\.JPG/' `find . -type f -name *.JPG`

find . -iname "*.jpg"  -print | while read name; do cur_dir=$(dirname "$name"); cur_file=$(basename "$name"); mv "$name" "$cur_dir/thumb_$cur_file"; done


------------------------------------
How do I merge one directory into another using Bash?
-------------------------------------

rsync --recursive html/ html_new/
rsync --av /path/to/source_folder/ /path/to/destination_folder/


-------------
rename
-------------


For example, to rename all files matching "*.bak" to strip the extension, you might say
rename 's/\e.bak$//' *.bak

To translate uppercase names to lower, you'd use
rename 'y/A-Z/a-z/' *


rename 's/^video_//' *.mp4 # select all filenames started with video_ and replace video_ with nothing
rename 's/^.*?_//' *.mp4
rename -n 's/^video_//' video_*.mp4
rename 's/^video_//' *.mp4

rename 's/\.html$/\.php/' *.html
rename -n 's/\.php$/\.html/' *.php
rename -v 's/\.php$/\.html/' *.php
rename 'y/a-z/A-Z/' *.html # to uppercase
rename 'y/A-Z/a-z/' *.HTML # to lowercase


for file in video_*.mp4; do mv -i "$file" "${file#video_}"; done # pattern to remove video_ from the start
for file in video_*.mp4; do mv -i "$file" "${file/video_/}"; done  # pattern to remove video_ from the start
for file in aro_tty-mIF-*_opt; do mv -i "${file}" "${file/-mIF-/-mImpFRA-}"; done # replace -mIF with -mImpFRA-
for f in *_opt; do a="$(echo $f | sed s/-mIF-/-mImpFRA-/)" &&  mv "$f" "$a"; done


--------------
random
--------------

echo $(($RANDOM % 100 + 1))
echo $(( ( RANDOM % 10 )  + 1 ))
echo $RANDOM % 10 + 1 | bc
r=$(( $RANDOM % 10 + 40 )); echo $r # range 40 - 49

echo date +%S%N|md5sum # f163a06dc98d52597edcaad926da13bb
echo date +%S%N # 00135508410 - same length
echo $RANDOM % 10 + 1 | bc
echo $RANDOM | tr '[0-9]' '[a-zA-Z]'
printf "%x"$(($RANDOM%169))
date +%s | sha256sum | base64 | head -c 32; echo
date +%s | sha256sum | base64 | head -c 12; echo
date +%s | sha256sum |  head -c 12; echo # 12 length
date | md5sum
openssl rand -base64 32
echo $(for((i=1;i<=13;i++)); do printf '%s' "${RANDOM:0:1}"; done)
for i in {0..31}; do string+=$(printf "%x" $(($RANDOM%16)) ); done; echo $string

####################
#
# rename
#
####################

# https://www.howtogeek.com/howto/30184/10-ways-to-generate-a-random-password-from-the-command-line/
# https://www.cyberciti.biz/tips/renaming-multiple-files-at-a-shell-prompt.html
POSIX shell rename all *.bak to *.txt
Use bash shell for loop as follows:
for j in *.bak; do mv -- "$j" "${j%.bak}.txt"; done
for j in *.bak; do mv -v -- "$j" "${j%.bak}.txt"; done


$ rename -v 's/\.JPG$/\.jpg/' *.JPG # 00001111.JPG renamed as 00001111.jpg
rename -n 's/(\d{8})\.JPG$/BeachPics_$1\.jpg/' *.JPG # 00001111.JPG renamed as BeachPics_00001111.jpg
rename -n 's/\d{5}(\d{3})\.JPG$/BeachPics_$1\.jpg/' *.JPG # 00000123.JPG renamed as BeachPics_123.jpg

$ N=1; for i in *.mp3; do echo mv $i TRACK_$N.mp3; N=$[N+1]; done
find /home/share2/TV_Series/ -name '[NAME]-S[0-9][0-9]E[0-9][0-9][EPISODE NAME].avi -exec mv {} [NAME]-S[0-9][0-9]E[0-9][0-9].avi
rename 's/the.simpsons.03x/TS-S03E/' *.avi

######################
#
# bash
#
#######################

#!/bin/sh

filePrefix="$1"
sequence=1

for file in $(ls -tr *.jpg) ; do
    renamedFile="$filePrefix$sequence.jpg"
    echo $renamedFile
    currentFile="$(echo $file)"
    echo "renaming \"$currentFile\" to $renamedFile"
    mv "$currentFile" "$renamedFile"
    sequence=$(($sequence+1))
done
exit 0

...

#!/bin/bash

if [ "$1" ]
then
  label="$1"
else
  echo missing parameter \(label\)
  exit 1
fi

for f in *.mp3
do
  if [ $( echo "$f" | grep -E -c '[0-9]+\.mp3$' ) == "0" ]
  then
    echo $f - skipped, track number not found
    continue
  fi
  i=${f%.mp3}
  i=${i##*[^0-9]}
  mv -v "$f" "$label"-$( printf '%02g' $i ).mp3
done

